
1.认识Frame类
    a.窗口类  setTitle() setSize() setResizable() windowLister
2.从Frame类继承

3.手动刷新--->自动刷新
    KeyAdapter  键盘监听处理类
        keyPressed、keyReleased

4. 1.注册GitHub    2.desktop.github.com  3.clone repository   4.填写项目 bjmashibing/tank   5.local path/空目录

5.如何定义主战坦克的方向
    根据按键改变主战坦克方向
    根据方向进行坦克的移动

    怎么设置坦克的静止
        对面对象的封装

    创建一个子弹类，使用画笔画出一颗子弹               坦克类、子弹类
    像象如何出更多的坦克，以及子弹
        1.这里有一个问题，页面闪烁，双缓冲问题   屏幕刷新很快，画笔没跟上。   使用系统画笔的update方法（这个方法每次都会先获取），先在内存中把图片画出来，然后再统一把图片画到屏幕上中
            （先走内存管理，再统一输出）
        2.  a.repaint-->update  b.截获update  c.首先把该画出的东西（坦克、子弹）先画在内存的图片中，图片大小和游戏画面一致   d.把内存图片一次性画到屏幕中（内存中的内容复制到显存）

    打出一颗子弹？
        假如按下Ctrl键，打出子弹，怎么去实现
        1.case 键盘的control键，抬起的时候发射子弹
        2.tank类的构造方法引入tankFrame类，可以直接操作子弹， tf.b = new Bullet(x,y,dir);

    打出一捐子弹
        1.使用容器List<Bullet>  在tankFrame中增加子弹的容器
        1.1 引出的边界问题，不作处理的话，容器里面的子弹越来越多，内存泄漏 内存泄漏很多会和容器相关，如果不再引用，但没有及时remove掉，会造成内存泄漏

        Exception in thread "AWT-EventQueue-0" java.util.ConcurrentModificationException
        当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。
        例如，某个线程在 Collection 上进行迭代时，通常不允许另一个线性修改该 Collection。通常在这些情况下，迭代的结果是不明确的。如果检测到这种行为，一些迭代器实现（包括 JRE 提供的所有通用 collection 实现）可能选择抛出此异常。执行该操作的迭代器称为快速失败 迭代器，因为迭代器很快就完全失败，而不会冒着在将来某个时间任意发生不确定行为的风险。
        注意，此异常不会始终指出对象已经由不同线程并发修改。如果单线程发出违反对象协定的方法调用序列，则该对象可能抛出此异常。例如，如果线程使用快速失败迭代器在 collection 上迭代时直接修改该 collection，则迭代器将抛出此异常。所以出现这种异常的通畅情况是使用了Iterator的原因，比如list。
        List<String> mm= new ArrayList<String>();
        mm.add("1");mm.add("34");
        for(String m : mm){
           System.out.println(m);
          }

        如果同时有其它线程对mm进行了修改，则抛出上面的异常。
        如果要避免这种错误，那么就不要使用Iterator,写成：
        for(int i = 0; i< mm.size();++i){
               println(mm.get(i));
        }


    坦克换乘图片、子弹换乘图片、     根据方向调整
    子弹中坦克的中心位置打出   根据坦克图片的大小，和左上角的位置计算子弹左上角的位置

    20220216
    1.new 出5个敌方坦克
    2.干掉敌人  碰撞检测   相交就算是碰到了
    3.干掉坦克之后，还需要把它remove掉，显示出坦克的数量
    4.坦克动起来
        4.1 单一的动，只要把moving设置为true就OK
        4.2 随机的动
        4.3 敌方坦克打出子弹   调用fire方法就可以，但是你需要分组，要不然，自己会打自己
            4.3.1 坦克需要加上一个属性，分组，子弹也是需要加上分组，区分
            4.3.2 碰撞检测，不开启队友伤害，敌方随机打出子弹
        4.4 加入爆炸，加入声音 画出一个爆炸
            4.4.1 用一个数组加入到内存
            4.4.2 新建一个explode类

    20220218
    1.美化坦克，使用旋转控制图片
    2.敌方坦克随机移动方向  使用random.nextInt()
    3.爆炸放到中心
        3.1 跟子弹的位置类似
    4.我军坦克、敌方坦克区分
        4.1 不能在使用同一张相片，区分图片
        4.2 使用group
    5.边界检测
        5.1 坦克移动到边界怎么处理？  在坦克类中处理
            if (this.x < 2) x = 2;
            if (this.y < 28) y = 28;
            if (this.x > TankFrame.GAME_WIDTH - Tank.WIDTH) x = TankFrame.GAME_WIDTH - Tank.WIDTH -2;
            if (this.y > TankFrame.GAME_HEIGHT - Tank.HEIGHT) y = TankFrame.GAME_HEIGHT - Tank.HEIGHT -2;

    6.rectangle问题处理
        bullet 和 tank 都新建一个Rectangle
        new bullet时，初始化rect,move时更新rect; new tank也是如此  在bullet和tank都维护一个rect

    7.代码开发都一定的程度，需要codeReview  和   Refactoring




    /Users/wangzhaobin/Downloads/tankProject/src/audio/tank_fire.wav
    20220219


    20220222
    1.配置文件，把相关的常量放到配置文件中，方便管理
        static Properties properties = new Properties();
            static {
                try {
                    properties.load(PropertyMgr.class.getClassLoader().getResourceAsStream("config"));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            public static String get(String key){
                if(properties == null) return null;
                return (String)properties.get(key);
            }


    20220223
    1.开火，弄成策略模式 FireStrategy
        1.1 敌方坦克开火只发一个   defaultFireStrategy
        1.2 我方坦克开火  fourDirFireStrategy
        1.3
                字段开火策略，
                 * 1.可以做成传参
                 *  1.1 做成传参，然后把defaultFireStrategy做成单例
                 *  1.2 传参，如果传入的没有做成单例，每次都要new一个对象。所以最好做成单例
                 * 2.作为坦克的一个成员变量，不需要做成单例
        1.4 配置文件，使用class.forName 加载类
            1.4.1 fireStrategy = (FireStrategy) Class.forName(goodFireStrategyName).newInstance()；


    20220224
    1.Information:java: javacTask: 源发行版 8 需要目标发行版 1.8
        Settings 搜索Java Compiler  --> target bytecode version 修改为8版本

    2.工厂模式
        任意定制交通工具
        任意定制生产过程
            CarFactory  --> Moveable createCar()    该方式 implement interface
        任意定制产品一族
            抽象工厂--工厂里面有三个抽象的产品--每个产品的有抽象的方法
            abstractFactory
                abstract Food   --abstract method
                abstract weapon     --abstract method
                abstract vehicle        --abstract method
            形容词使用接口，名词使用抽象类

        简单工厂VS抽象工厂
        1.简单工厂更容易扩展，生产过程也比较容易扩展  产品单一上比较容易扩展
        2.抽象工厂在产品一族上容易扩展，但引出一个问题，父类改了，所有的子类都需要改。有取有舍
        3.能不能兼容1和2呢 有，那就是Spring的bean工厂

    20220225
        1.Class.forName加载的是某包下的类， 如果你的包是tank,那么你要加载就想  Class.forName("tank.xxx");

        2.抽象工厂  设置一个GameFactory 里面有三个抽象的类   BaseTank、baseBullet、baseExplode
                    public abstract BaseTank createTank(int x, int y, Dir dir, Group group);
                    public abstract BaseExplode createExplode(int x, int y, TankFrame tf);
                    public abstract BaseBullet createBullet(int x, int y, Dir dir, Group group, TankFrame tf);

            2.1 具体工厂  DefaultFactory 继承 GameFactory
            2.2 具体工厂  RectFactory 继承 GameFactory
            2.3 Bullet继承BaseBullet  Explode extends BaseExplode

    20220226
        1.抽象工厂 一键换产品族 画风一键换

    20220228
        mac中看是否已经安装了git     终端 git --version   (查看路径)- which git  该方法也是可以使用于别的工具类


    20220302
        1.git 提交代码遇到   LibreSSL SSL_connect: Operation timed out in connection to github.com:433
            解决方法： git remote set-url origin git@github.com:名字/仓库名.git       git remote set-url origin git@github.com:zhaobin-wang/tank.git

        2.生成秘钥
            1.设置账号和邮箱
               git config --global user.name "自已的用户"    例：git config --global user.name "fenlin"
               git config --global user.email "自己的邮箱"     例：git config --global user.email "wei@163.com"
            2.查看秘钥是否存在
               cd ~/.ssh
            3.生成秘钥
               ssh-keygen -t rsa -C "自己的邮箱与上面邮箱一致" 按三次回车   例： ssh-keygen -t rsa -C "wei@163.com"

            4.查看秘钥，并复制到码云或github的ssh里

              cat ~/.ssh/id_rsa.pub

            ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD9S2lo0iALjcBeE7dlCpXN+dN3asjaABIQOjAQJSKM
            ho+UL2LQJhmbPhYQyio2IRV4sHgXUSXseZ8Dzo/B8oBiC94h25rrIb8UMmKp3Cctk1e1LabmhIVwzAZt


    20220303
        idea怎么提交代码到Git
        IDEA:VCS-->Import into Version Control-->Create Git Repository
        IDEA：VCS-->Git-->Add添加当前项目下的文件，添加完成之后，之前的红色文件名变成了绿色了，表示已经Add成功。
        IDEA:VCS-->Git-->Push
        将gitlab上面的仓库地址获取到    （这里要注意，需要远程仓库里面有一个项目）  git@github.com:zhaobin-wang/tank 4cpyHpyryUqGbE4hy+7vBcBGwGjuQBR1cixJn3v+nc6jGtF+4UlIXDSOu9sYMiyCuqGKCjqQjvLDGRul                                                                                                                VmtJ8eROPMJLlRZ43Xg+vTFz0jH3EJP8OnguU+EH82XMHhgDpD0xyWS/mVcDKtYh4rUL/Ky8fXQuxY3b                                  RU5QKjHYuw88E3impT7VZz9IRcJQUtet9xVh69/qyH56SGfxZ/LjbjUbuEcR 987679265@qq.com

        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
        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
        2.String to List
            List<String> list = Splitter.on(",").splitToList(Str);   需要依赖  guava


    20220304
        枚举
        public enum CourseStatusEnum{
            LEAVE(1,"xxx"),
            OT_LEAVE(0,"xxx");

            private final Integer stats;
            private final String desc;

            CourseStatusEnum(Integer status, String desc){
                this.status = status;
                this.desc = desc;
            }

            public Integer getStatus(){
                return stats;
            }
            public String getDesc(){
                return desc;
            }

        }


    20220305
        1.改包位置之后，配置文件里面需要修改为   tank.DefaultFireStrategy   之前在代码上加tank. 的方式很low
        2.GameObject
        3.碰撞检测  因为现在都是物体碰撞物体 怎么去区分是什么碰什么
            3.1 Collider 碰撞接口，任何的碰撞都实现这个接口，然后自己处理。最后全部遍历一遍，做相互的碰撞    子弹和坦克的碰撞（BulletTankCollider） (坦克和坦克的相撞)TankTankCollider
            3.2 责任链 ColliderChain 做成责任链
                3.2.1 ColliderChain自己也实现Collider，这样的好处，可以直接add到责任链里面    只要前面的已经碰撞，就不需要往下（返回值，进行判断）
                3.2.2 为了更好的初始化，需要把新的ColliderChain放到配置文件.最终回归配置文件。
                3.2.3
        4.改变idea的快捷方式（常用）  -- setting--keymap--intellij IDEA Classic

    20220306
        1.设计理念  高内聚，低耦合
            1.1 继承--耦合度最高     聚合（属性）--耦合度其次   关联（方法的参数，方法的返回值）--a类不是b类的属性，但是在B类的方法里面，
        2.GameModel做成单例
            2.1 因为做成单例，Bullet初始化不需要把GameModel传进来，而是直接  GameModel.getInstance().add(this);
            2.2 代码重构，解耦合
            2.3 加了一堵墙
        3.Decorator 装饰器
            3.1 GODecorator 抽象类    RectDecorator、TailDecorator 都去继承 GODecorator
            3.2 注意点：位置需要往后传， 在paint里面this.x = go.x  this.y = go.y
            3.3 GODecorator聚合一个GameObject

    20220307
        Observer    事件处理模型  一般和责任链模式一起使用
        定义一个接口，子类去实现它
        1.观察者只和事件打交道，不会和事件源打交道，这样观察者就和事件源解耦合了
        2.事件类，会有一个source属性

    20220310
        1.在很多系统中，observer模式往往和责任链共同负责对于事件的处理，其中的某一个observer负责是否将事件进一步传递
        2.当你按下fire事件，做对应的处理
            2.1 一个观察者 TankFireObserver
            2.2 事件 TankFireEvent 里面是tank,有getSource方法
            2.3 具体事件处理类 TankFireHandler 从TankFireObserver实现，具体的fire()动作
            2.4 在坦克类增加很多的TankFireEvent  当按键时，坦克会发出这个时间，然后挨着遍历每一个observer，目前只有一个，让她处理事件。现在简单的处理就是拿到原对象，让它去fire
            2.5 钩子函数就是 observer
        3.composite 模式
            3.1 组合模式，一般都是用来做树状结构的，    递归+深度 可以方便的看出树状   每次遍历都加上

        4.享元模式  使用同一个，不在new 新的

    20220314
        1.git push
            1.1 git push <远程主机名> <本地分支名>:<远程分支名>
                1.1.1 如果本地分支名与远程分支名相同，则可以省略冒号：git push <远程主机名> <本地分支名>


    20220315
        1.代理  proxy
            1.1 日志代理 时间代理 Moveable接口   tank实现Moveable/tankTimeProxy也实现moveable/TankLogProxy也实现moveable接口
            1.2 tankTimeProxy和tankLogProxy都聚合moveable
            1.3 new TankLogProxy(
                    new TankTimeProxy(
                        new Tank()
                    )
                ).move();       先打日志，后打出时间

        2.动态代理
            System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");

    20220316
        1.System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");  生成代理类
        2.scala/kotlin 最终还是会生成class文件，在JVM运行
        3.JDK proxy面向接口,tank必须实现一个接口，要不没法处理
        4.cglib  final的类不能使用cglib做代理，但asm可以（控制的是字节码）
        5.aop
            5.1     <bean id="tank" class="com.wangzhaobin.dp.spring.v1.Tank"/>
                    <!--切的类-->
                    <bean id="timeProxy" class="com.wangzhaobin.dp.spring.v1.TimeProxy"/>

                    <aop:config>
                        <aop:aspect id="time" ref="timeProxy">
                            <!--execution(void com.wangzhaobin.dp.spring.v1.Tank.*) 所有方法-->
                            <aop:pointcut id="onmove" expression="execution(void com.wangzhaobin.dp.spring.v1.Tank.move())"/>
                            <aop:before method="before" pointcut-ref="onmove"/>
                            <aop:after method="after" pointcut-ref="onmove"/>
                        </aop:aspect>
                    </aop:config>

            5.2 自动代理
                5.2.1 先引入
                            <dependency>
                                <groupId>org.aspectj</groupId>
                                <artifactId>aspectjweaver</artifactId>
                                <version>1.9.4</version>
                            </dependency>
                5.2.2
                        配置文件
                        <aop:aspectj-autoproxy/>
                        <bean id="tank" class="com.wangzhaobin.dp.spring.v2.Tank"/>
                        <bean id="timeProxy" class="com.wangzhaobin.dp.spring.v2.TimeProxy"/>

                        注解代理
                        @Aspect
                        public class TimeProxy {

                            @Before("execution(void com.wangzhaobin.dp.spring.v2.Tank.move())")
                            public void before(){
                                log.info("method start....{}",System.currentTimeMillis());
                            }

                            @After("execution(void com.wangzhaobin.dp.spring.v2.Tank.move())")
                            public void after(){
                                log.info("method end...{}", System.currentTimeMillis());
                            }


                        }

            5.3 ioc+aop

    20220323
        1.数组VS链表


    20220324
        1.AST（抽象语法树）
        2.ASM


    20220326
        1. List<String> list = Arrays.asList('','');这种创建的list，addAll时会报错。   ArrayList 继承的AbstractList类，AbstractList类的add方法就不能使用


    20220327
        1.责任链 filter 过去是123 回来是321  request 过去123顺序 response回来321顺序
        怎么做到的呢？加上一个下标，判断每次执行doFilter时要不要再往下执行，如果是添加了，就往下执行，response放到doFilter后面执行就OK了。
        2.Builder模式   对象属性比较多时，使用该模式比较好
            2.1 Person里面多个属性，写一个静态内部类 可以比较好的构建对象   使用的方法就是 new PersonBuilder().BaseBuilder(xxx,xxx).build();
        3.adapter  适配器（Wrapper）也叫包装器模式   转接头      从一个不能直接到另一个，中间加上一个转接头
            3.1 常见的adapter类反而不是adapter模式（注意）  比如 KeyAdapter   只需要写你关心的方法，而不是全部的写，这是一种编程方式，方便编程  可以看下 WindowAdapter

        4.桥接模式   bridge模式  用聚合代替继承      两个维度的发展   抽象类自己实现一支，实现类自己实现一支，但是在抽象类里面聚合一个具体实现。相互不影响，也不会造成类爆炸


    20220328
        1.protoType 原型模式
            1.1 要想使用clone()方法，类必须实现 Cloneable接口 要想复制一个类，第一步需要实现Cloneable接口，第二步需要重写clone方法


    20220329
        1.memento和序列化
            1.1 实现坦克位置的存盘以及读盘
                1.1.0 按下s键时保存此时坦克的位置，l键回到上一次保存的位置
                    1.1.0.1 流记得要close()
                1.1.1 当一个对象要序列化时，它所引用的对象也需要序列化，要不然汇报异常
                1.1.2 也可以使用 transient（透明） 关键词，这样序列化不会报错，但load不回来
                1.1.3 还要一个最简单的方法实现序列化，GameObject 实现序列化，但是这样就不能演示 先写哪个，先拿哪个的演示

        2.templateMethod 模板方法（钩子函数）   父类定义了方法，子类具体实现，
        3.state 模式
            3.1 把状态抽象出来，   abstract MMState 里面有三个抽象方法，子类MMState,具体根据状态，调用具体的子类。
            3.1 有限状态机（FSM)



    20220330
        1.intepreter解释器


    20220401
        网络编程    烦点：异常处理、正确关闭->线程的正常结束


    20220419
        git 查看远程分支    git branch -r

