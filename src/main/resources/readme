
1.认识Frame类
    a.窗口类  setTitle() setSize() setResizable() windowLister
2.从Frame类继承

3.手动刷新--->自动刷新
    KeyAdapter  键盘监听处理类
        keyPressed、keyReleased

4. 1.注册GitHub    2.desktop.github.com  3.clone repository   4.填写项目 bjmashibing/tank   5.local path/空目录

5.如何定义主战坦克的方向
    根据按键改变主战坦克方向
    根据方向进行坦克的移动

    怎么设置坦克的静止
        对面对象的封装

    创建一个子弹类，使用画笔画出一颗子弹               坦克类、子弹类
    像象如何出更多的坦克，以及子弹
        1.这里有一个问题，页面闪烁，双缓冲问题   屏幕刷新很快，画笔没跟上。   使用系统画笔的update方法（这个方法每次都会先获取），先在内存中把图片画出来，然后再统一把图片画到屏幕上中
            （先走内存管理，再统一输出）
        2.  a.repaint-->update  b.截获update  c.首先把该画出的东西（坦克、子弹）先画在内存的图片中，图片大小和游戏画面一致   d.把内存图片一次性画到屏幕中（内存中的内容复制到显存）

    打出一颗子弹？
        假如按下Ctrl键，打出子弹，怎么去实现
        1.case 键盘的control键，抬起的时候发射子弹
        2.tank类的构造方法引入tankFrame类，可以直接操作子弹， tf.b = new Bullet(x,y,dir);

    打出一捐子弹
        1.使用容器List<Bullet>  在tankFrame中增加子弹的容器
        1.1 引出的边界问题，不作处理的话，容器里面的子弹越来越多，内存泄漏 内存泄漏很多会和容器相关，如果不再引用，但没有及时remove掉，会造成内存泄漏

        Exception in thread "AWT-EventQueue-0" java.util.ConcurrentModificationException
        当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。
        例如，某个线程在 Collection 上进行迭代时，通常不允许另一个线性修改该 Collection。通常在这些情况下，迭代的结果是不明确的。如果检测到这种行为，一些迭代器实现（包括 JRE 提供的所有通用 collection 实现）可能选择抛出此异常。执行该操作的迭代器称为快速失败 迭代器，因为迭代器很快就完全失败，而不会冒着在将来某个时间任意发生不确定行为的风险。
        注意，此异常不会始终指出对象已经由不同线程并发修改。如果单线程发出违反对象协定的方法调用序列，则该对象可能抛出此异常。例如，如果线程使用快速失败迭代器在 collection 上迭代时直接修改该 collection，则迭代器将抛出此异常。所以出现这种异常的通畅情况是使用了Iterator的原因，比如list。
        List<String> mm= new ArrayList<String>();
        mm.add("1");mm.add("34");
        for(String m : mm){
           System.out.println(m);
          }

        如果同时有其它线程对mm进行了修改，则抛出上面的异常。
        如果要避免这种错误，那么就不要使用Iterator,写成：
        for(int i = 0; i< mm.size();++i){
               println(mm.get(i));
        }


    坦克换乘图片、子弹换乘图片、     根据方向调整
    子弹中坦克的中心位置打出   根据坦克图片的大小，和左上角的位置计算子弹左上角的位置

    20220216
    1.new 出5个敌方坦克
    2.干掉敌人  碰撞检测   相交就算是碰到了
    3.干掉坦克之后，还需要把它remove掉，显示出坦克的数量
    4.坦克动起来
        4.1 单一的动，只要把moving设置为true就OK
        4.2 随机的动
        4.3 敌方坦克打出子弹   调用fire方法就可以，但是你需要分组，要不然，自己会打自己
            4.3.1 坦克需要加上一个属性，分组，子弹也是需要加上分组，区分
            4.3.2 碰撞检测，不开启队友伤害，敌方随机打出子弹
        4.4 加入爆炸，加入声音 画出一个爆炸
            4.4.1 用一个数组加入到内存
            4.4.2 新建一个explode类

    20220218
    1.美化坦克，使用旋转控制图片
    2.敌方坦克随机移动方向  使用random.nextInt()
    3.爆炸放到中心
        3.1 跟子弹的位置类似
    4.我军坦克、敌方坦克区分
        4.1 不能在使用同一张相片，区分图片
        4.2 使用group
    5.边界检测
        5.1 坦克移动到边界怎么处理？  在坦克类中处理
            if (this.x < 2) x = 2;
            if (this.y < 28) y = 28;
            if (this.x > TankFrame.GAME_WIDTH - Tank.WIDTH) x = TankFrame.GAME_WIDTH - Tank.WIDTH -2;
            if (this.y > TankFrame.GAME_HEIGHT - Tank.HEIGHT) y = TankFrame.GAME_HEIGHT - Tank.HEIGHT -2;

    6.rectangle问题处理
        bullet 和 tank 都新建一个Rectangle
        new bullet时，初始化rect,move时更新rect; new tank也是如此  在bullet和tank都维护一个rect

    7.代码开发都一定的程度，需要codeReview  和   Refactoring




    /Users/wangzhaobin/Downloads/tankProject/src/audio/tank_fire.wav
    20220219


    20220222
    1.配置文件，把相关的常量放到配置文件中，方便管理
        static Properties properties = new Properties();
            static {
                try {
                    properties.load(PropertyMgr.class.getClassLoader().getResourceAsStream("config"));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            public static String get(String key){
                if(properties == null) return null;
                return (String)properties.get(key);
            }


    20220223
    1.开火，弄成策略模式 FireStrategy
        1.1 敌方坦克开火只发一个   defaultFireStrategy
        1.2 我方坦克开火  fourDirFireStrategy
        1.3
                字段开火策略，
                 * 1.可以做成传参
                 *  1.1 做成传参，然后把defaultFireStrategy做成单例
                 *  1.2 传参，如果传入的没有做成单例，每次都要new一个对象。所以最好做成单例
                 * 2.作为坦克的一个成员变量，不需要做成单例
        1.4 配置文件，使用class.forName 加载类
            1.4.1 fireStrategy = (FireStrategy) Class.forName(goodFireStrategyName).newInstance()；


    20220224
    1.Information:java: javacTask: 源发行版 8 需要目标发行版 1.8
        Settings 搜索Java Compiler  --> target bytecode version 修改为8版本

    2.工厂模式
        任意定制交通工具
        任意定制生产过程
            CarFactory  --> Moveable createCar()    该方式 implement interface
        任意定制产品一族
            抽象工厂--工厂里面有三个抽象的产品--每个产品的有抽象的方法
            abstractFactory
                abstract Food   --abstract method
                abstract weapon     --abstract method
                abstract vehicle        --abstract method
            形容词使用接口，名词使用抽象类

        简单工厂VS抽象工厂
        1.简单工厂更容易扩展，生产过程也比较容易扩展  产品单一上比较容易扩展
        2.抽象工厂在产品一族上容易扩展，但引出一个问题，父类改了，所有的子类都需要改。有取有舍
        3.能不能兼容1和2呢 有，那就是Spring的bean工厂

    20220225
        1.Class.forName加载的是某包下的类， 如果你的包是tank,那么你要加载就想  Class.forName("tank.xxx");

        2.抽象工厂  设置一个GameFactory 里面有三个抽象的类   BaseTank、baseBullet、baseExplode
                    public abstract BaseTank createTank(int x, int y, Dir dir, Group group);
                    public abstract BaseExplode createExplode(int x, int y, TankFrame tf);
                    public abstract BaseBullet createBullet(int x, int y, Dir dir, Group group, TankFrame tf);

            2.1 具体工厂  DefaultFactory 继承 GameFactory
            2.2 具体工厂  RectFactory 继承 GameFactory
            2.3 Bullet继承BaseBullet  Explode extends BaseExplode

    20220226
        1.抽象工厂 一键换产品族 画风一键换

    20220228
        mac中看是否已经安装了git     终端 git --version   (查看路径)- which git  该方法也是可以使用于别的工具类


    20220302
        1.git 提交代码遇到   LibreSSL SSL_connect: Operation timed out in connection to github.com:433
            解决方法： git remote set-url origin git@github.com:名字/仓库名.git       git remote set-url origin git@github.com:zhaobin-wang/tank.git

        2.生成秘钥
            1.设置账号和邮箱
               git config --global user.name "自已的用户"    例：git config --global user.name "fenlin"
               git config --global user.email "自己的邮箱"     例：git config --global user.email "wei@163.com"
            2.查看秘钥是否存在
               cd ~/.ssh
            3.生成秘钥
               ssh-keygen -t rsa -C "自己的邮箱与上面邮箱一致" 按三次回车   例： ssh-keygen -t rsa -C "wei@163.com"

            4.查看秘钥，并复制到码云或github的ssh里

              cat ~/.ssh/id_rsa.pub

            ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD9S2lo0iALjcBeE7dlCpXN+dN3asjaABIQOjAQJSKM
            ho+UL2LQJhmbPhYQyio2IRV4sHgXUSXseZ8Dzo/B8oBiC94h25rrIb8UMmKp3Cctk1e1LabmhIVwzAZt


    20220303
        idea怎么提交代码到Git
        IDEA:VCS-->Import into Version Control-->Create Git Repository
        IDEA：VCS-->Git-->Add添加当前项目下的文件，添加完成之后，之前的红色文件名变成了绿色了，表示已经Add成功。
        IDEA:VCS-->Git-->Push
        将gitlab上面的仓库地址获取到    （这里要注意，需要远程仓库里面有一个项目）  git@github.com:zhaobin-wang/tank 4cpyHpyryUqGbE4hy+7vBcBGwGjuQBR1cixJn3v+nc6jGtF+4UlIXDSOu9sYMiyCuqGKCjqQjvLDGRul                                                                                                                VmtJ8eROPMJLlRZ43Xg+vTFz0jH3EJP8OnguU+EH82XMHhgDpD0xyWS/mVcDKtYh4rUL/Ky8fXQuxY3b                                  RU5QKjHYuw88E3impT7VZz9IRcJQUtet9xVh69/qyH56SGfxZ/LjbjUbuEcR 987679265@qq.com

        2.String to List
            List<String> list = Splitter.on(",").splitToList(Str);   需要依赖  guava


    20220304
        枚举
        public enum CourseStatusEnum{
            LEAVE(1,"xxx"),
            OT_LEAVE(0,"xxx");

            private final Integer stats;
            private final String desc;

            CourseStatusEnum(Integer status, String desc){
                this.status = status;
                this.desc = desc;
            }

            public Integer getStatus(){
                return stats;
            }
            public String getDesc(){
                return desc;
            }

        }


    20220305
        1.改包位置之后，配置文件里面需要修改为   tank.DefaultFireStrategy   之前在代码上加tank. 的方式很low







